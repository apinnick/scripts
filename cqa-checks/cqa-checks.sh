#!/bin/bash
# Avital Pinnick, 2025

OUTPUT="CQA-report.md"
ASSEMBLIES="assemblies.txt"
MODULES="modules-list.txt"
rm $OUTPUT &>/dev/null

echo -e "# Content Quality Assessment report\n" >> $OUTPUT
echo -e "This report describes Content Quality Assessment issues found in Asciidoc assemblies and modules in a master.adoc file.\n" >> $OUTPUT
echo -e "For details, see the [Modular documentation templates checklist](https://docs.google.com/document/d/13NAUVAby1y1qfT77QFIZrMBhi872e7IEvAC9MUpGXbQ/edit?tab=t.0).\n" >> $OUTPUT
echo -e "Important: This report is generated by the [cqa-checks](https://github.com/apinnick/scripts/blob/main/cqa-checks/cqa-checks.sh) script. It is a work on progress. There might be errors. Please send feedback to [Avital Pinnick](mailto:apinnick@redhat.com).\n" >> $OUTPUT

# Check if $ASSEMBLIES exists
if [[ ! -f "$ASSEMBLIES" ]]; then
  echo "Error: $ASSEMBLIES not found!"
  rm $OUTPUT &>/dev/null
  exit 1
fi

# Check if $MODULES exists
if [[ ! -f "$MODULES" ]]; then
  echo "Error: $MODULES not found!"
  rm $OUTPUT &>/dev/null
  exit 1
fi

# Remove double slashes from $ASSEMBLIES
sed -i "s|\/\/|\/|" $ASSEMBLIES

echo -e Checking "$ASSEMBLIES" and "$MODULES"

# File checks
echo -e "## File checks\n" >> $OUTPUT
echo "Checking all files for general issues"

# Check for content type attribute
echo -e "Content type attribute missing or invalid:\n" >> $OUTPUT
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  # Check if the specific line *is* present in the file
  if grep -P "^:_mod-docs-content-type: " "$1" > /dev/null; then
    # If it *is* present, do nothing (or handle the "present" case)
    : # A no-op command
  else
    # If it is *not* present (grep returned 1), then print the file name
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Anchor ID
echo -e "ID missing:\n" >> $OUTPUT
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  # Check if the specific line *is* present in the file
  if grep -P "^\[id.*\]" "$1" > /dev/null; then
    # If it *is* present, do nothing (or handle the "present" case)
    : # A no-op command
  else
    # If it is *not* present (grep returned 1), then print the file name
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Long titles
echo -e "Title longer than 10 words found:\n" >> $OUTPUT
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
    # Find lines starting with "= ", "== ", or "=== "
    grep -E "^={1,3} " "$1" | while IFS= read -r line; do
        # Remove the leading "={1,3} " and count the words
        word_count=$(echo "$line" | sed -E "s/^={1,3} //" | wc -w)
        # Check if word count is greater than 10
        if [ "$word_count" -gt 10 ]; then
            echo "- $1"
            # Break the inner loop and go to the next file if a match is found
            break
        fi
    done
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# Blank line after '= ' header
echo -e "'= ' header not followed by blank line:\n" >> $OUTPUT
# Generated by Gemini
AWK_SCRIPT=$(cat <<'EOF_AWK'
# Rule 1: When a line matches the pattern /^\s*=\s*[A-Za-z]/
/^\s*=\s*[A-Za-z]/ {
    found_pattern_line = 1; # Set flag that we found the pattern
    next; # Move to the next line to check
}

# Rule 2: This block executes for every line.
# It checks if the current line is the one immediately following the pattern.
{
    if (found_pattern_line == 1) {
        # Check if the current line is NOT blank AND NOT "endif::[]"
        if ($0 !~ /^[[:space:]]*$/ && ($0 !~ /^endif::\[\]\s*$/)) {
            print FILENAME; # Print filename if it meets criteria
            exit;           # Exit successfully (found a match)
        }
        # If the line was blank OR contained "endif::[]", reset the flag
        # and continue processing, as this sequence doesn't count as a match.
        found_pattern_line = 0;
    }
}

# Rule 3: This END block handles the case where the pattern line is the last line of the file.
# In this scenario, there's no subsequent line, so by definition, it's not
# followed by a blank line or "ifdef[]". So, we consider it a match.
END {
    if (found_pattern_line == 1) {
        print FILENAME; # Print filename if pattern was last line
    }
}
EOF_AWK
)

cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
    FILE="$1"
    AWK_SCRIPT="$2" # AWK script is passed as the second argument
    # Execute awk using the passed script content
    if echo "$AWK_SCRIPT" | awk -f /dev/stdin "$FILE" | grep -q "^$FILE$"; then
        echo "- $FILE"
    fi
' _ {} "$AWK_SCRIPT" >> "$OUTPUT"
echo -e "- _Done_\n" >> "$OUTPUT"

# Admonition titles
# [NOTE], [WARNING], etc., must not be followed by a block title.
echo -e "Admonition with title found:\n" >> $OUTPUT
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  if grep -Pzo "(?s)\[[A-Z]+\]\n\.[A-Za-z].*" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Image without text description
echo -e "Image without description found:\n" >> $OUTPUT
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  if grep -E "^image.*\[\]$" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# ASSEMBLY CHECKS
echo -e "\n## Assembly module checks\n" >> $OUTPUT
echo "Checking assemblies"

# Check assembly for more than one title (= )
echo -e "More than one '= ' header found:\n" >> $OUTPUT
cat $ASSEMBLIES | xargs -I {} sh -c '
  count=$(grep -P -c "^= [A-Za-z0-9]" "$1")
  if [ "$count" -ge 2 ]; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check assembly for '=== ' header
echo -e "'=== ' header found:\n" >> $OUTPUT
cat $ASSEMBLIES | xargs -I {} sh -c '
  if grep -P "^=== [A-Z0-9].*" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check for block titles
echo -e "Block title ('.Text') found:\n" >> $OUTPUT
cat $ASSEMBLIES | xargs -I {} sh -c '
  if grep -P "^\." "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check nested assemblies for 'ifdef::context[:parent-context: {context}]'
echo -e "Nested assembly conditions\n" >> $OUTPUT

echo -e "\n- Missing 'ifdef::context[:parent-context: {context}]':\n" >> $OUTPUT
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifdef::context\[:parent-context: {context}\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

echo -e "\n- Missing 'ifdef::parent-context[:context: {parent-context}]':\n" >> $OUTPUT
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifdef::parent-context\[:context: {parent-context}\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

echo -e "\n- Missing 'ifndef::parent-context[:!context:]':\n" >> $OUTPUT
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifndef::parent-context\[:!context:\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

# PROCEDURES
echo -e "## Procedure module checks\n" >> $OUTPUT
echo "Checking procedure modules"

# Procedure with '== ' header
echo -e "'== ' header found:\n" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  if grep -P "^:_mod-docs-content-type: PROCEDURE" "$1" > /dev/null; then
    if grep -P "^== [A-Z0-9].*" "$1" > /dev/null; then
    echo "- $1"
    fi
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# LONG PROCEDURE
echo -e "Procedure longer than 10 steps found:\n" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  steps=$(grep -E "^\. [A-Z]" "$1" | wc -l)
  if (( steps >= 10 )); then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Invalid block title
echo -e "Block title other than Prerequisites, Procedure, Troubleshooting, Next steps, Additional resources, or Verification found:\n" >> $OUTPUT
cat "$MODULES" | xargs -I {} sh -c '
  FILE="$1"
  if grep -P "^:_mod-docs-content-type: PROCEDURE" "$1" > /dev/null; then
    if grep -iPq "(?s)^\.(?!\.{1,3}|\s[A-Z]|Prerequisites|Procedure|Troubleshooting|Next steps|Additional resources|Verification).*" "$FILE"; then
      echo "- $FILE"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# More than one procedure
echo -e "More than one procedure found:\n" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  count=$(grep -P -c "^\.Procedure" "$1")
  if [ "$count" -ge 2 ]; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Invalid procedure block title
echo -e "Invalid 'Procedure' title found:" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  if grep -Pq "^\.Procedure.+" "$1"; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Procedure followed by text - IN PROGRESS
echo -e "'Procedure' title not followed by list found:\n" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  FILE="$1"
  if grep -iP "(?s)^\.Procedure\n(?:^[[:space:]]*\n)?(?!^\.|\*)(?=^[A-Z]).*" "$FILE"; then
    echo "- $FILE"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# CONCEPT AND REFERENCE MODULES
echo -e "## Concept and Reference module checks\n" >> $OUTPUT
echo "Checking concept and reference modules"

# Invalid block title
echo -e "Block title other than 'Next steps' or 'Additional resources' found:\n" >> $OUTPUT
cat "$MODULES" | xargs -I {} sh -c '
  FILE="$1"
  if grep -P "^:_mod-docs-content-type: (CONCEPT|REFERENCE)" "$1" > /dev/null; then
    if grep -iPq "(?s)^\.(?!\.{1,3}|\s[A-Z]|Next steps|Additional resources).*" "$FILE"; then
      echo "- $FILE"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# '=== ' header
echo -e "'=== ' header found:\n" >> $OUTPUT
cat $MODULES | xargs -I {} sh -c '
  if grep -P "^:_mod-docs-content-type: (CONCEPT|REFERENCE)" "$1" > /dev/null; then
    if grep -P "^=== [A-Z0-9a-z].*" "$1" > /dev/null; then
    echo "- $1"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# END
echo "Done. CQA-report.md created."
