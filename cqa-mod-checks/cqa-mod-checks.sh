#!/bin/bash
# Avital Pinnick and Gemini

OUTPUT="CQA-mod-report.md"
SUMMARY="CQA-mod-checks-summary.md"
ASSEMBLIES="assemblies.txt"
MODULES="modules-list.txt"
rm $OUTPUT &>/dev/null

echo -e "# CQA modularization report\nCreated $(date +"%Y-%m-%d")\n" >> $OUTPUT
echo -e "# CQA modularization checks summary\nCreated $(date +"%Y-%m-%d")\n" > $SUMMARY
echo -e "This report describes modularization issues found in '$ASSEMBLIES' and '$MODULES'. For details, see the [Modular documentation templates checklist](https://docs.google.com/document/d/13NAUVAby1y1qfT77QFIZrMBhi872e7IEvAC9MUpGXbQ/edit?tab=t.0) and [CQA template](https://docs.google.com/spreadsheets/d/11LyS_q40rF0IQ0p-U-ZG1legKHB7dKbv8Kn279wqvpA/edit?usp=drive_link).\n" >> $OUTPUT

echo -e "The [cqa-mod-checks script](https://github.com/apinnick/scripts/blob/main/cqa-mod-checks/cqa-mod-checks.sh) is a work on progress and might contain errors. Feedback: [Avital Pinnick](mailto:apinnick@redhat.com).\n" >> $OUTPUT

# Check if $ASSEMBLIES exists
if [[ ! -f "$ASSEMBLIES" ]]; then
  echo "Error: $ASSEMBLIES not found!"
  rm $OUTPUT &>/dev/null
  exit 1
fi

# Check if $MODULES exists
if [[ ! -f "$MODULES" ]]; then
  echo "Error: $MODULES not found!"
  rm $OUTPUT &>/dev/null
  exit 1
fi

# Remove double slashes from $ASSEMBLIES
sed -i "s|\/\/|\/|" $ASSEMBLIES

echo -e Checking "$ASSEMBLIES" and "$MODULES:"

# File checks
CHECK="File checks"
echo -e "## $CHECK\n" >> $OUTPUT
echo -e "**$CHECK**\n" >> $SUMMARY
echo $CHECK

# Check for content type attribute
CHECK="Content type attribute missing or invalid"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  # Check if the specific line *is* present in the file
  if grep -P "^:_mod-docs-content-type: " "$1" > /dev/null; then
    # If it *is* present, do nothing (or handle the "present" case)
    : # A no-op command
  else
    # If it is *not* present (grep returned 1), then print the file name
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Anchor ID
CHECK="ID missing"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  # Check if the specific line *is* present in the file
  if grep -P "^\[id.*\]" "$1" > /dev/null; then
    # If it *is* present, do nothing (or handle the "present" case)
    : # A no-op command
  else
    # If it is *not* present (grep returned 1), then print the file name
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Long titles
CHECK="Title longer than 10 words found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
    # Find lines starting with "= ", "== ", or "=== "
    grep -E "^={1,3} " "$1" | while IFS= read -r line; do
        # Remove the leading "={1,3} " and count the words
        word_count=$(echo "$line" | sed -E "s/^={1,3} //" | wc -w)
        # Check if word count is greater than 10
        if [ "$word_count" -gt 10 ]; then
            echo "- $1"
            # Break the inner loop and go to the next file if a match is found
            break
        fi
    done
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# Blank line after '= ' header
CHECK="'= ' header not followed by blank line"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
# Generated by Gemini
AWK_SCRIPT=$(cat <<'EOF_AWK'
# Rule 1: When a line matches the pattern /^\s*=\s*[A-Za-z]/
/^\s*=\s*[A-Za-z]/ {
    found_pattern_line = 1; # Set flag that we found the pattern
    next; # Move to the next line to check
}

# Rule 2: This block executes for every line.
# It checks if the current line is the one immediately following the pattern.
{
    if (found_pattern_line == 1) {
        # Check if the current line is NOT blank AND NOT "endif::[]"
        if (($0 !~ /^[[:space:]]*$/) && ($0 !~ /^endif::\[\]\s*$/)) {
            print FILENAME; # Print filename if it meets criteria
            exit;           # Exit successfully (found a match)
        }
        # If the line was blank OR contained "endif::[]", reset the flag
        # and continue processing, as this sequence doesn't count as a match.
        found_pattern_line = 0;
    }
}

# Rule 3: This END block handles the case where the pattern line is the last line of the file.
# In this scenario, there's no subsequent line, so by definition, it's not
# followed by a blank line or "ifdef[]". So, we consider it a match.
END {
    if (found_pattern_line == 1) {
        print FILENAME; # Print filename if pattern was last line
    }
}
EOF_AWK
)

cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
    FILE="$1"
    AWK_SCRIPT="$2" # AWK script is passed as the second argument
    # Execute awk using the passed script content
    if echo "$AWK_SCRIPT" | awk -f /dev/stdin "$FILE" | grep -q "^$FILE$"; then
        echo "- $FILE"
    fi
' _ {} "$AWK_SCRIPT" >> "$OUTPUT"
echo -e "- _Done_\n" >> "$OUTPUT"

# Admonition titles
# [NOTE], [WARNING], etc., must not be followed by a block title.
CHECK="Admonition with title found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  if grep -Pzo "(?s)\[[A-Z]+\]\n\.[A-Za-z].*" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Image without text description
CHECK="Image without description found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES $MODULES | xargs -I {} sh -c '
  if grep -E "^image.*\[\]$" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# ASSEMBLY CHECKS
CHECK="Assembly checks"
echo -e "## $CHECK:\n" >> $OUTPUT
echo -e "\n**$CHECK**\n" >> $SUMMARY
echo $CHECK

# Check assembly for more than one title (= )
CHECK="More than one '= ' header found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES | xargs -I {} sh -c '
  count=$(grep -P -c "^= [A-Za-z0-9]" "$1")
  if [ "$count" -ge 2 ]; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check assembly for '=== ' header
CHECK="'=== ' header found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES | xargs -I {} sh -c '
  if grep -P "^=== [A-Z0-9].*" "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check for block titles
CHECK="Block title ('.Text') found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $ASSEMBLIES | xargs -I {} sh -c '
  if grep -P "^\." "$1" > /dev/null; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Check nested assemblies for 'ifdef::context[:parent-context: {context}]'
CHECK="Nested assembly conditions"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY

CHECK="'ifdef::context[:parent-context: {context}]' missing"
echo -e "- $CHECK:\n" >> $OUTPUT
echo -e "  - $CHECK" >> $SUMMARY
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifdef::context\[:parent-context: {context}\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

CHECK="'ifdef::parent-context[:context: {parent-context}]' missing"
echo -e "- $CHECK:\n" >> $OUTPUT
echo -e "  - $CHECK" >> $SUMMARY
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifdef::parent-context\[:context: {parent-context}\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

CHECK="'ifndef::parent-context[:!context:]' missing"
echo -e "- $CHECK:\n" >> $OUTPUT
echo -e "  - $CHECK" >> $SUMMARY
cat nested-assemblies.txt | xargs -I {} sh -c '
  if grep -Pv "ifndef::parent-context\[:!context:\]" "$1" > /dev/null; then
    echo "  - $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "  - _Done_\n" >> $OUTPUT

CHECK="'include::' on consecutive lines"
# echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- To do: $CHECK" >> $SUMMARY

# PROCEDURES
CHECK="Procedure module checks"
echo -e "## $CHECK:\n" >> $OUTPUT
echo -e "\n**$CHECK**\n" >> $SUMMARY
echo $CHECK

# Procedure with '== ' header
CHECK="'== ' header found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  if grep -P "^:_mod-docs-content-type: PROCEDURE" "$1" > /dev/null; then
    if grep -P "^== [A-Z0-9].*" "$1" > /dev/null; then
    echo "- $1"
    fi
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# LONG PROCEDURE
CHECK="Procedure longer than 10 steps found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  steps=$(grep -E "^\. [A-Z]" "$1" | wc -l)
  if (( steps >= 10 )); then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Invalid block title
CHECK="Block title other than Prerequisites, Procedure, Troubleshooting, Next steps, Additional resources, or Verification found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat "$MODULES" | xargs -I {} sh -c '
  FILE="$1"
  if grep -P "^:_mod-docs-content-type: PROCEDURE" "$1" > /dev/null; then
    if grep -iPq "(?s)^\.(?!\.{1,3}|\s[A-Z]|Prerequisites|Procedure|Troubleshooting|Next steps|Additional resources|Verification).*" "$FILE"; then
      echo "- $FILE"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# More than one procedure
CHECK="More than one procedure found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  count=$(grep -P -c "^\.Procedure" "$1")
  if [ "$count" -ge 2 ]; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Invalid procedure block title
CHECK="Invalid Procedure title found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  if grep -Pq "^\.Procedure.+" "$1"; then
    echo "- $1"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# Procedure followed by text - IN PROGRESS
CHECK="Procedure not followed by list found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  FILE="$1"
  if grep -iP "(?s)^\.Procedure\n(?:^[[:space:]]*\n)?(?!^\.|\*)(?=^[A-Z]).*" "$FILE"; then
    echo "- $FILE"
  fi
' _ {} >> "$OUTPUT"
echo -e "- _Done_\n" >> $OUTPUT

# CONCEPT AND REFERENCE MODULES
CHECK="Concept and reference module checks"
echo -e "## $CHECK:\n" >> $OUTPUT
echo -e "\n**$CHECK**\n" >> $SUMMARY
echo $CHECK

# Invalid block title
CHECK="Block title other than 'Next steps' or 'Additional resources' found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat "$MODULES" | xargs -I {} sh -c '
  FILE="$1"
  if grep -P "^:_mod-docs-content-type: (CONCEPT|REFERENCE)" "$1" > /dev/null; then
    if grep -iPq "(?s)^\.(?!\.{1,3}|\s[A-Z]|Next steps|Additional resources).*" "$FILE"; then
      echo "- $FILE"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# '=== ' header
CHECK="'=== ' header found"
echo -e "$CHECK:\n" >> $OUTPUT
echo -e "- $CHECK" >> $SUMMARY
cat $MODULES | xargs -I {} sh -c '
  if grep -P "^:_mod-docs-content-type: (CONCEPT|REFERENCE)" "$1" > /dev/null; then
    if grep -P "^=== [A-Z0-9a-z].*" "$1" > /dev/null; then
    echo "- $1"
    fi
  fi
' _ {} >> $OUTPUT
echo -e "- _Done_\n" >> $OUTPUT

# END
echo -e "Done.\nCQA-report.md and CQA-checks-summary.md created."
